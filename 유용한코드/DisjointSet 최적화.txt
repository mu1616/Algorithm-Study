위와 같이 구현할 경우, 최악의 경우 트리의 장점을 전혀 살릴 수 없는 연결 리스트 형태가 
되면 union 과 find연산 모두 O(n)이 되버릴 수 있다.
이 문제는 두 트리를 합칠 때, 항상 높이가 더 낮은 트리를 높은 트리 밑에 넣음으로써 해결이 가능하다.
이렇게 되면, 트리의 높이가 크게 높아지는 상황을 방지 할 수 있다.

이러한 최적화를 union-by-rank라 하며, 여기서 rank는 해당 트리의 높이를 저장합니다.
코드 :
//rank에 트리의 높이를 저장하며
//두 트리의 rank가 동일하여 높이가 높아져야만 하는 경우에는
//합병 후 결과 트리의 rank를 1 증가 시켜준다.
//
//이 최적화 과정을 거치면 트리의 높이는 합쳐진 두 트리의 높이가 같을 때만 증가하게 된다.
//높이가 h인 트리가 만들어 지기 위해서는 높이가 h-1인 두개의 트리가 합쳐져야 하고,
//즉, 최적화를 통해 트리의 높이가 포함한 노드의 수의 로그에 비례하는 것을 보장하게 되므로
//union과 find 연산의 시간복잡도가 O(logN)이 된다.

int find(int u) {
	if (u == parent[u]) 
		return u;
	
	//parent를 찾아낸 루트로 아예 바꿔 버리면
	//find 연산 수행시 중복되는 연산을 줄여준다.
	//재귀적인 구현 덕분에 u에서 루트까지 올라가는 경로상에 있는 
	//모든 노드들에게도 경로 압축 최적화가 자동으로 수행된다.
	return parent[u] = find(parent[u]);
}

void union(int u, int v) {
	u = find(u);
	v = find(v);
	
	if(u == v) return;
	
	if(rank[u] > rank[v]) 
		swap(u, v);
		
	parent[u] = v;
	//두 트리의 높이가 같은경우에는 결과 트리의 rank를 1 높혀준다.
	if(rank[u] == rank[v]) rank[v]++;
	
}