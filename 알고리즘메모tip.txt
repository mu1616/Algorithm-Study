1. 조건을 만족하는 것을 뽑는다 = 일단 뽑고 조건을 만족하는지 확인한다.   
2. 나만의 조합, 순열 알고리즘을 만들어놓자! (특정 배열에서 가능한 조합 전부 출력 또는 배열로 생성)
3. long 타입, 배열의 길이가 매우 크다면 배열선언 안하고 풀어보자 (메모리 초과) -> map,set 이용고려
4. 0부터 시작이 아니라 1부터 시작일경우 k+1크기의 배열을 선언하고 0번째 인덱스 없는것처럼 하자
5. 다음 노드 저장 -> 해쉬맵으로 가능!, 만약 중복되는 요소가 있을 경우 다음노드를 속성으로 가지는 Class 만들고 list에 저장..?
6. 방문여부 -> visited 배열, hashset, hashmap
7. 문제 잘 읽고 중요하다 생각되는 부분은 적어놓자!!! 메모장이든 노트든
8. 범위를 보고 모든 경우의 수를 탐색하는 완탐문제를 파악해야한다. 
	범위가 이렇게 주어졌는데 효율적인 코드 생각하는 순간 시험 볼 때 큰일난다.
9. 주어진 테스트 케이스는 맞았는데 다른 케이스들은 틀리 때 -> 다른 예시를 고려해보자 (간단한거부터)
10. 어떤 경우의 수를 생각 할 떄는 반드시 반대의 경우도 생각 
	( ex) 오른쪽에 무언가가 있을때, 왼쪽에 무언가가있을때, 왼쪽오른쪽 아무것도 없을 때, 왼쪽오른쪽 둘다 있을 때)
11. 이진 탐색 문제는 어떤 것을 이진 탐색 할 것인지를 찾기만 하면 수월하게 풀 수 있다!!
12. 효율성 문제 -> 시간복잡도로 생각해보자
13. break문 잘걸자
14. Set 의 contains 시간복잡도는 O(1) 이고 List의 contains 시간복잡도는 O(n) 이다.
     자바 시간복잡도 : https://soft.plusblog.co.kr/74
15. 서로다른 요소의 개수 -> 해쉬 이용!!! (addall -> size) 
16. 리스트가 비었는지 확인 할 때, list.isEmpty() 쓰는게 시간복잡도 빠름
17. 새로운 클래스를 정의해서 풀어보자!
18. compare 구현할때는 같을 때= return 0; 도 해주어야 오류 안난다
19. Set의 정렬 ==> TreeSet만들고 addAll()
21. n개의 요소의 상태 -> int array[n] 선언후 상태를 -1,0,1 등을 표현
22. List 쓸 때 시간복잡도에 주의하자!! 예를들어 remove 는 O(n) 이므로 remove 없이 짤수 있다면 없이 짜보자
23. 정렬 할지 말지 잘 결정하자
24. Integer.ParseInt 는 앞에 0이 있을경우 자동으로 없앤다.  예를들어 035 -> 35로 변환
25. 피보나치 처럼 숫자가 엄청나게 커지는 경우 int 말고 long 쓰자
26. 완전탐색 -> 반복문, 재귀
27. 후위증감연산자 조심하자!!!!!! function(a++) 라고 하면 function 에는 a가전달된다!
28. 어떤 배열에 포함되는지 여부를 매 반복마다 따져야 할때 오버헤드가 크다면 포함안되는 리스트를 만들어서 포함되지 않는지  
     여부를 따져보자.  (반대도 가능)  , 혹은 visit배열 
29. visit 배열 = [0,1,0,0,0,0,1...] , visitList = 방문한 노드 추가  --> visit배열로 판단하는것이 훨씬 효율적!  ex)백준1987번
30. 중복되는 요소가 없다 -> 정렬 의심 
31. String에 +=을 하는 건 기존 String의 내용에 뒤의 String의 내용을 이어붙인 새로운 문자열을 만들어서 담고, 
원래의 문자열은 더 참조하는 레퍼런스가 없으면 GC에 들어가게 됩니다. 이 버려진 문자열이 정확히 언제 메모리에서 
완전히 해제되는지는 모르겠지만, 그 전까지는 계속 메모리상에 누적되어 큰 용량을 차지하는 것으로 보입니다.
문자열을 길게 계속 이어붙이려면 StringBuilder를 사용해야 합니다.